//! There is public traits for `Regex` and `Match` structs generated by `regn`.
//! It allows to interact with multiple instances of those structs outside of
//! place their creation.

pub trait RegexBytes {
    fn match_at<'h>(&self, haystack: &'h [u8], start: usize) -> Option<impl MatchBytes<'h>>;

    fn match_iter<'h>(&self, haystack: &'h [u8]) -> impl Iterator<Item = impl MatchBytes<'h>>;
}

pub trait MatchBytes<'h> {
    fn as_bytes(&self) -> &'h [u8];

    fn start(&self) -> usize;

    fn end(&self) -> usize;

    #[inline]
    fn len(&self) -> usize {
        self.end() - self.start()
    }

    #[inline]
    fn is_empty(&self) -> bool {
        self.start() == self.end()
    }

    #[inline]
    fn range(&self) -> std::ops::Range<usize> {
        self.start()..self.end()
    }
}

pub trait RegexStr {
    fn match_at<'h>(&self, haystack: &'h str, start: usize) -> Option<impl MatchStr<'h>>;

    fn match_iter<'h>(&self, haystack: &'h str) -> impl Iterator<Item = impl MatchStr<'h>>;
}

pub trait MatchStr<'h>: MatchBytes<'h> {
    fn as_str(&self) -> &'h str;
}

// It is more a playground than a test collection.
#[cfg(test)]
mod utest {
    #[test]
    fn test_match() {
        let re = {
            use super::*;

            struct Match0<'h> {
                capture: &'h str,
                start: usize,
            }

            impl<'h> Match0<'h> {
                #[inline]
                pub fn start(&self) -> usize {
                    self.start
                }

                #[inline]
                fn end(&self) -> usize {
                    self.start + self.capture.len()
                }

                #[inline]
                fn len(&self) -> usize {
                    self.capture.len()
                }

                #[inline]
                fn is_empty(&self) -> bool {
                    self.capture.is_empty()
                }

                #[inline]
                fn range(&self) -> std::ops::Range<usize> {
                    self.start..self.end()
                }

                #[inline]
                fn as_str(&self) -> &'h str {
                    self.capture
                }

                #[inline]
                pub fn as_bytes(&self) -> &'h [u8] {
                    self.as_str().as_bytes()
                }
            }

            impl<'h> MatchBytes<'h> for Match0<'h> {
                #[inline]
                fn start(&self) -> usize {
                    self.start()
                }

                #[inline]
                fn end(&self) -> usize {
                    self.end()
                }

                #[inline]
                fn len(&self) -> usize {
                    self.len()
                }

                #[inline]
                fn is_empty(&self) -> bool {
                    self.is_empty()
                }

                #[inline]
                fn range(&self) -> std::ops::Range<usize> {
                    self.range()
                }

                #[inline]
                fn as_bytes(&self) -> &'h [u8] {
                    self.as_bytes()
                }
            }

            impl<'h> MatchStr<'h> for Match0<'h> {
                #[inline]
                fn as_str(&self) -> &'h str {
                    self.as_str()
                }
            }

            struct Regex;

            impl RegexStr for Regex {
                fn match_at<'h>(
                    &self,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<impl MatchStr<'h>> {
                    self.match_at(haystack, start)
                }

                fn match_iter<'h>(
                    &self,
                    haystack: &'h str,
                ) -> impl Iterator<Item = impl MatchStr<'h>> {
                    [Match0 {
                        capture: haystack,
                        start: 0,
                    }]
                    .into_iter()
                }
            }

            impl Regex {
                fn match_at<'h>(&self, haystack: &'h str, _start: usize) -> Option<Match0<'h>> {
                    Some(Match0 {
                        capture: &haystack[0..haystack.len()],
                        start: 0,
                    })
                }
            }

            Regex
        };

        let m = re.match_at("hello", 0).unwrap();
        assert_eq!(m.start(), 0);
        assert_eq!(m.end(), 5);
        assert_eq!(m.len(), 5);
        assert!(!m.is_empty());
        assert_eq!(m.range(), 0..5);
        assert_eq!(m.as_str(), "hello");
        assert_eq!(m.as_bytes(), &[104, 101, 108, 108, 111]);

        test_my_match(m);
    }

    fn test_my_match<'h>(m: impl super::MatchStr<'h>) {
        _ = m.start();
        //
    }
}
