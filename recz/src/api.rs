//! There is public traits for `Regex` and `Match` structs generated by `regn`.
//! It allows to interact with multiple instances of those structs outside of
//! place their creation.

pub trait RegexBytes {
    fn match_to<'h>(&self, haystack: &'h [u8]) -> Option<impl MatchBytes<'h>>;

    fn match_at<'h>(&self, haystack: &'h [u8], start: usize) -> Option<impl MatchBytes<'h>>;

    fn match_iter<'h>(&self, haystack: &'h [u8]) -> impl Iterator<Item = impl MatchBytes<'h>>;
}

pub trait MatchBytes<'h> {
    fn as_bytes(&self) -> &'h [u8];

    fn start(&self) -> usize;

    fn end(&self) -> usize;

    #[inline]
    fn len(&self) -> usize {
        self.end() - self.start()
    }

    #[inline]
    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    #[inline]
    fn range(&self) -> std::ops::Range<usize> {
        self.start()..self.end()
    }
}

pub trait RegexStr {
    fn is_match(&self, haystack: &str) -> bool;

    fn match_to<'h>(&self, haystack: &'h str) -> Option<impl MatchStr<'h>>;

    fn match_at<'h>(&self, haystack: &'h str, start: usize) -> Option<impl MatchStr<'h>>;

    fn match_iter<'h>(&self, haystack: &'h str) -> impl Iterator<Item = impl MatchStr<'h>>;
}

pub trait MatchStr<'h>: MatchBytes<'h> {
    fn as_str(&self) -> &'h str;
}

// It is more a playground than a test suite.
#[cfg(test)]
mod utest {
    // #![allow(refining_impl_trait)]

    #[test]
    fn test_match() {
        let re = {
            use super::*;

            struct MyMatch<'h> {
                capture: &'h str,
            }

            impl<'h> MatchBytes<'h> for MyMatch<'h> {
                #[inline]
                fn as_bytes(&self) -> &'h [u8] {
                    self.as_bytes()
                }

                #[inline]
                fn start(&self) -> usize {
                    self.start()
                }

                #[inline]
                fn end(&self) -> usize {
                    self.end()
                }
            }

            impl<'h> MatchStr<'h> for MyMatch<'h> {
                #[inline]
                fn as_str(&self) -> &'h str {
                    self.capture
                }
            }

            impl<'h> MyMatch<'h> {
                #[inline]
                pub fn as_bytes(&self) -> &'h [u8] {
                    self.capture.as_bytes()
                }

                #[inline]
                pub fn start(&self) -> usize {
                    0
                }

                #[inline]
                fn end(&self) -> usize {
                    1
                }

                #[inline]
                fn len(&self) -> usize {
                    self.end() - self.start()
                }

                #[inline]
                fn is_empty(&self) -> bool {
                    self.len() == 0
                }

                #[inline]
                fn range(&self) -> std::ops::Range<usize> {
                    self.start()..self.end()
                }

                #[inline]
                fn as_str(&self) -> &'h str {
                    self.capture
                }
            }

            struct MyRegex;

            impl RegexBytes for MyRegex {
                fn match_to<'h>(&self, haystack: &'h [u8]) -> Option<impl MatchBytes<'h>> {
                    self.match_to(haystack)
                }

                fn match_at<'h>(
                    &self,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<impl MatchBytes<'h>> {
                    self.match_at(haystack, start)
                }

                fn match_iter<'h>(
                    &self,
                    _haystack: &'h [u8],
                ) -> impl Iterator<Item = impl MatchBytes<'h>> {
                    [MyMatch { capture: "" }].into_iter()
                }
            }

            impl MyRegex {
                fn match_to<'h>(&self, _haystack: &'h [u8]) -> Option<MyMatch<'h>> {
                    Some(MyMatch { capture: "hello" })
                }

                fn match_at<'h>(&self, _haystack: &'h [u8], _start: usize) -> Option<MyMatch<'h>> {
                    Some(MyMatch { capture: "hello" })
                }
            }

            MyRegex
        };

        let m = re.match_to(b"hello").unwrap();
        let _ = re.match_at(b"hello", 0).unwrap();
        assert_eq!(m.start(), 0);
        assert_eq!(m.end(), 1);
        assert_eq!(m.len(), 1);
        assert!(!m.is_empty());
        assert_eq!(m.range(), 0..1);
        assert_eq!(m.as_str(), "hello");
        assert_eq!(m.as_bytes(), &[104, 101, 108, 108, 111]);

        test_my_match(m);
    }

    fn test_my_match<'h>(m: impl super::MatchStr<'h>) {
        _ = m.start();
        //
    }
}
